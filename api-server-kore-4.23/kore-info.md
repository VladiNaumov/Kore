
Чтобы понять, как работает код в Kore, давайте разберем последовательность действий, начиная с запуска сервера и заканчивая обработкой запросов. Рассмотрим основные этапы, начиная с самого первого файла, который участвует в процессе, до завершения обработки запроса.

### 1. **Запуск Kore (main.c)**

Когда вы запускаете сервер Kore, выполнение начинается с файла `main.c`, который обычно содержит точку входа программы — функцию `main()`. Это тот файл, где начинается настройка сервера и запуск его различных компонентов.

Пример:
   ```c
   int main(int argc, char *argv[])
   {
       /* Инициализация Kore */
       kore_init();

       /* Настройка маршрута (маршрутизатор) */
       http_route("/test", HTTP_GET, handle_request);

       /* Запуск сервера */
       kore_start();
       
       return (0);
   }
   ```

- **kore_init()**: Инициализирует необходимые структуры данных и настройки Kore.
- **http_route()**: Регистрирует маршрут (например, для пути `/test`).
- **kore_start()**: Запускает сервер Kore, начиная цикл обработки входящих соединений.

### 2. **Инициализация и настройка компонентов (kore_init() и kore_start())**

После вызова `kore_init()`, сервер начинает подготавливать все свои внутренние ресурсы, включая:
- Настройку сетевых интерфейсов.
- Инициализацию логирования.
- Загрузку всех зарегистрированных модулей (например, `accesslog.c`, `sha2.c` и т. д.).
- Настройку обработчиков для различных типов запросов (например, HTTP-запросов).

В `kore_start()` сервер начинает слушать на определенном порту (например, 8080). Этот этап включает в себя запуск цикла событий, который будет обрабатывать входящие запросы.

### 3. **Обработка входящих запросов**

Когда клиент отправляет запрос на сервер, Kore получает его через сетевой интерфейс. Сетевой код, вероятно, будет использовать такие компоненты как `linux.c` для работы с сокетами и управления входящими соединениями.

В Kore есть основной цикл обработки событий (event loop), который ждет новых соединений и запросов. Когда запрос приходит, Kore передает его обработчику, который был зарегистрирован с помощью функции `http_route()`.

### 4. **Выбор маршрута (http_route)**

Когда запрос приходит, Kore проверяет его путь (URL) и метод (например, GET или POST). Он использует маршрутизатор, чтобы найти соответствующий обработчик.

В нашем примере:
   ```c
   http_route("/test", HTTP_GET, handle_request);
   ```
Этот код говорит Kore, что все GET-запросы к пути `/test` должны обрабатываться функцией `handle_request`.

### 5. **Обработка запроса (handle_request)**

В функции обработчика запроса, Kore предоставляет вам доступ к объекту `http_request`, который содержит информацию о запросе:
- `req->method`: HTTP-метод (например, GET, POST).
- `req->path`: Путь запроса.
- `req->remote_ip`: IP-адрес клиента.

Пример обработки запроса:
   ```c
   void handle_request(struct http_request *req)
   {
       /* Логируем запрос */
       kore_log(LOG_NOTICE, "Received request: %s %s from %s", req->method, req->path, req->remote_ip);

       /* Отправляем ответ */
       http_response(req, 200, "OK", 2);
   }
   ```

- **kore_log()**: Логирует информацию о запросе.
- **http_response()**: Отправляет ответ клиенту, например, статус 200 (OK).

### 6. **Отправка ответа**

После того как обработка запроса завершена, Kore отправляет ответ клиенту через сетевой интерфейс. Ответ может содержать:
- HTTP-статус (например, 200, 404).
- Заголовки.
- Тело ответа (например, текст или HTML).

### 7. **Завершение обработки и возвращение к циклу событий**

После отправки ответа Kore возвращается к ожиданию следующих запросов, продолжая работу в цикле событий, который был начат в `kore_start()`.

### Дополнительные компоненты

- **Модули (например, accesslog.c, tls_none.c)**: Эти модули загружаются и выполняются в процессе работы сервера. Например, модуль `accesslog.c` может записывать все запросы в файл логов, а модуль `tls_none.c` может отключать шифрование (что полезно для отладки, но не для продакшн-среды).

- **Асинхронные задачи (tasks.c)**: Если в процессе обработки запроса необходимо выполнить асинхронную задачу (например, загрузка данных из базы данных), Kore использует свой механизм асинхронных задач. Это позволяет не блокировать основной поток и обрабатывать другие запросы.

---

### Общая структура выполнения:

1. **main()** — точка входа, инициализация Kore, настройка маршрутов.
2. **kore_init()** — настройка ресурсов.
3. **kore_start()** — запуск сервера.
4. **Цикл обработки событий** — сервер начинает ожидать запросы.
5. **http_route()** — маршрутизация запросов.
6. **handle_request()** — обработка запроса.
7. **http_response()** — отправка ответа.
8. **Цикл возвращается к ожиданию следующего запроса.**

Каждый из этих этапов можно детально разбирать, настраивать и модифицировать в зависимости от требований вашего проекта.

В каталоге `SRC/` исходного кода в Kore.

1. **`src/kore.c`** – основной файл, который инициализирует Kore и управляет жизненным циклом приложения.
   - Модуль: Инициализация и управление сервером.
   - Код в этом файле запускает сервер, обрабатывает сигналы и выполняет основные операции с маршрутизацией и обработкой запросов.

   Пример:
   ```c
   int main(int argc, char *argv[]) {
       kore_init();
       kore_run();
       return 0;
   }
   ```

2. **`src/http.c`** – модуль, который обрабатывает HTTP-запросы.
   - Модуль: HTTP обработка.
   - Код здесь отвечает за обработку входящих HTTP-запросов, создание и отправку HTTP-ответов.

   Пример:
   ```c
   void kore_handle_http_request(struct http_request *req) {
       // Обработка HTTP запроса
       if (req->method == HTTP_METHOD_GET) {
           http_response(req, 200, "text/plain", "Hello World");
       }
   }
   ```

3. **`src/connection.c`** – управление соединениями.
   - Модуль: Соединение.
   - Этот файл отвечает за управление клиентскими соединениями, а также за создание и уничтожение соединений с сервером.

   Пример:
   ```c
   void kore_connection_accept(struct connection *conn) {
       // Принятие нового соединения
       conn->fd = accept_connection(conn);
       kore_start_reading(conn);
   }
   ```

4. **`src/auth.c`** – аутентификация.
   - Модуль: Аутентификация пользователей.
   - Код для проверки идентификации и авторизации пользователей. Обрабатывает логины и пароли.

   Пример:
   ```c
   int kore_authenticate_user(const char *username, const char *password) {
       // Проверка данных пользователя
       if (strcmp(username, "admin") == 0 && strcmp(password, "password123") == 0) {
           return 1; // Успешная аутентификация
       }
       return 0; // Ошибка аутентификации
   }
   ```

5. **`src/tls_openssl.c`** (или аналог для другого бэкенда) – работа с TLS.
   - Модуль: TLS шифрование.
   - Этот файл отвечает за реализацию защищенного соединения с использованием SSL/TLS, например, через OpenSSL.

   Пример:
   ```c
   int kore_tls_init(struct tls *tls_ctx) {
       // Инициализация SSL/TLS
       SSL_library_init();
       tls_ctx->ssl = SSL_new(tls_ctx->ctx);
       return 0;
   }
   ```

6. **`src/route.c`** – маршруты.
   - Модуль: Определение маршрутов.
   - Этот файл обрабатывает маршрутизацию запросов, например, какие функции вызываются для каждого пути.

   Пример:
   ```c
   void kore_add_route(const char *path, route_handler handler) {
       // Добавление маршрута
       routes[path] = handler;
   }
   ```

7. **`src/json.c`** – работа с JSON.
   - Модуль: Работа с JSON.
   - Этот файл отвечает за обработку JSON-данных, например, сериализацию и десериализацию.

   Пример:
   ```c
   void kore_json_parse(const char *data) {
       // Парсинг JSON
       json_object *jobj = json_tokener_parse(data);
       // Дальше обработка jobj
   }
   ```

8. **`src/log.c`** – логирование.
   - Модуль: Логирование.
   - Обрабатывает вывод логов, например, для отслеживания ошибок или действий на сервере.

   Пример:
   ```c
   void kore_log(int level, const char *fmt, ...) {
       // Логирование сообщений
       va_list args;
       va_start(args, fmt);
       vfprintf(log_file, fmt, args);
       va_end(args);
   }
   ```


9. **`src/buf.c`** – буферы.
   - Модуль: Управление буферами.
   - Этот файл обычно содержит функции для работы с буферами данных, например, для чтения и записи в сетевые соединения или для обработки запросов/ответов.

   Пример:
   ```c
   void buf_init(struct buffer *buf, size_t size) {
       buf->data = malloc(size);
       buf->size = size;
   }

   void buf_free(struct buffer *buf) {
       free(buf->data);
   }
   ```

10. **`src/config.c`** – конфигурация.
   - Модуль: Загрузка и обработка конфигурации.
   - Этот файл отвечает за чтение конфигурационных файлов и настройку параметров сервера. Он может быть полезен, если вы хотите изменить параметры работы Kore через конфиг.

   Пример:
   ```c
   int config_load(const char *filename) {
       // Загрузка конфигурации из файла
       FILE *config_file = fopen(filename, "r");
       if (!config_file) {
           return -1;
       }
       // Парсинг конфигурации
       fclose(config_file);
       return 0;
   }
   ```

11. **`src/domain.c`** – домены.
   - Модуль: Управление доменами.
   - Используется для обработки доменов, например, в виртуальных хостах или настройках DNS.

   Пример:
   ```c
   void domain_init(const char *domain_name) {
       // Инициализация домена
       printf("Initializing domain: %s\n", domain_name);
   }
   ```

12. **`src/fileref.c`** – работа с файловыми ссылками.
   - Модуль: Работа с файлами.
   - В этом файле могут быть функции, которые работают с файловыми путями или хранят ссылки на файлы для дальнейшей работы.

   Пример:
   ```c
   int fileref_open(const char *filename) {
       // Открытие файла
       FILE *file = fopen(filename, "r");
       if (!file) {
           return -1;
       }
       return fileno(file);
   }
   ```

13. **`src/jsonrpc.c`** – JSON-RPC.
   - Модуль: Обработка JSON-RPC.
   - Этот файл может содержать функции для работы с JSON-RPC, который используется для взаимодействия через API с другими системами.

   Пример:
   ```c
   void jsonrpc_handle_request(struct jsonrpc_request *req) {
       // Обработка JSON-RPC запроса
       printf("Handling JSON-RPC request\n");
   }
   ```

14. **`src/msg.c`** – обмен сообщениями.
   - Модуль: Обмен сообщениями.
   - Этот файл может отвечать за отправку и получение сообщений, может использоваться для сообщений между процессами или сетевыми соединениями.

   Пример:
   ```c
   void msg_send(struct connection *conn, const char *message) {
       // Отправка сообщения через соединение
       send(conn->fd, message, strlen(message), 0);
   }
   ```

15. **`src/mem.c`** – управление памятью.
   - Модуль: Управление памятью.
   - Этот файл может включать в себя функции для выделения и освобождения памяти, например, для управления памятью в пуле или в других частях приложения.

   Пример:
   ```c
   void *mem_alloc(size_t size) {
       return malloc(size);
   }

   void mem_free(void *ptr) {
       free(ptr);
   }
   ```

16. **`src/timer.c`** – таймеры.
   - Модуль: Работа с таймерами.
   - Этот файл может отвечать за установку и обработку таймеров, например, для отслеживания времени выполнения запросов или для периодических задач.

   Пример:
   ```c
   void timer_start(struct timer *t, uint32_t ms) {
       t->start_time = current_time_ms();
       t->timeout = ms;
   }
   ```

17. **`src/worker.c`** – рабочие потоки.
   - Модуль: Обработка через рабочие потоки.
   - Этот файл управляет пулом рабочих потоков, например, для обработки запросов параллельно, улучшая производительность.

   Пример:
   ```c
   void worker_process_request(struct request *req) {
       // Обработка запроса рабочим потоком
       process_request(req);
   }
   ```

18. **`src/sha1.c`, `src/sha2.c`** – криптографические хеш-функции.
    - Модуль: Криптографические функции.
    - Эти файлы могут содержать реализацию алгоритмов хеширования SHA-1 и SHA-2 для использования в безопасности и валидации данных.

    Пример:
    ```c
    void sha1_hash(const char *input, char *output) {
        // Реализация хеширования SHA1
    }
    ```

19. **`src/pgsql.c`** – работа с PostgreSQL.
    - Модуль: Подключение и работа с PostgreSQL.
    - Этот файл обрабатывает подключение к базе данных PostgreSQL и выполнение SQL-запросов.

    Пример:
    ```c
    void pgsql_query(const char *query) {
        // Выполнение SQL-запроса
    }
    ```

20. **accesslog.c**  
   Модуль для записи логов доступа (например, HTTP-запросов). Он отслеживает каждый запрос, записывая данные о клиенте, запросе и ответе.  
   **Пример**: Модуль может записывать строки типа: `"2025-01-28 14:00:01 - 192.168.1.1 - GET /index.html 200 OK"`.

21. **acme.c**  
   Используется для работы с протоколом ACME, который необходим для автоматической генерации SSL/TLS-сертификатов (например, через Let's Encrypt).

22. **bsd.c**  
   Этот модуль включает в себя функционал, специфичный для систем на базе BSD. Он может содержать реализации, которые зависят от особенностей этих систем.

23. **cli.c**  
   Модуль для командной строки, который позволяет запускать Kore в режиме консоли. Он может быть использован для настройки и управления сервером через командную строку.

24. **curl.c**  
   Этот модуль позволяет интегрировать Kore с внешними сервисами через HTTP-запросы, используя библиотеку libcurl. Он может быть использован для вызова REST API из вашего приложения.

25. **linux.c**  
   Модуль для специфической работы с системами на базе Linux. Он может включать в себя различные утилиты и функции, связанные с управлением ресурсами и операционной системой.

26. **module.c**  
   Основной модуль, который управляет модулями Kore. Он предоставляет функции для загрузки и управления другими модулями.

27. **pool.c**  
   Модуль для работы с пулом памяти. Он позволяет эффективно управлять памятью, особенно при высоком уровне параллелизма и большим количестве клиентов.

28. **python.c**  
   Модуль, который интегрирует Kore с Python, позволяя запускать Python-скрипты и использовать Python-библиотеки прямо в сервере Kore.

29. **runtime.c**  
    Обеспечивает функциональность для выполнения кода в реальном времени, управляя потоками и асинхронными операциями в Kore.

30. **seccomp.c**  
    Использует механизмы безопасности Linux (seccomp) для фильтрации системных вызовов, повышая безопасность сервера, ограничивая доступ к опасным функциям ОС.

31. **sha2.c**  
    Реализует алгоритмы хеширования SHA-2, которые можно использовать для создания безопасных хешей и проверок данных.

32. **tasks.c**  
    Модуль для планирования и выполнения асинхронных задач в Kore. Может быть использован для обработки задач, которые не требуют немедленного выполнения в основном потоке.

33. **tls_none.c**  
    Модуль для работы без TLS. Это может быть полезно для разработки и тестирования, когда шифрование не требуется.

34. **utils.c**  
    Вспомогательные функции, которые используются другими модулями Kore для выполнения общих задач, таких как обработка строк, управление памятью и другие утилиты.

35. **validator.c**  
    Модуль для проверки данных, например, входных параметров в запросах, проверок форматов данных или значений. Это может быть полезно для валидирования запросов от клиента.

36. **websocket.c**  
    Реализует поддержку WebSocket-протокола для двустороннего общения между клиентом и сервером в реальном времени.

Пример использования **accesslog.c** для записи логов:

```c
#include <kore/kore.h>
#include <kore/accesslog.h>

void handle_request(struct http_request *req)
{
    /* Записываем лог запроса */
    kore_log(LOG_NOTICE, "Access log: %s - %s %s", req->remote_ip, req->method, req->path);
    
    /* Ответ на запрос */
    http_response(req, 200, "OK", 2);
}

int main()
{
    /* Инициализация Kore */
    kore_init();
    
    /* Настройка маршрута */
    http_route("/test", HTTP_GET, handle_request);
    
    /* Запуск сервера */
    kore_start();
    
    return (0);
}
```

Этот код будет записывать каждый запрос, сделанный к серверу, в лог с IP-адресом клиента, методом HTTP и путем запроса.
### Как это связано:
Все эти файлы объединены в единую систему и выполняют разные задачи. Основной файл, например, `src/kore.c`, запускает сервер, и зависит от этих вспомогательных файлов для выполнения различных операций, таких как обработка HTTP-запросов, работа с базой данных, шифрование и так далее.

Вы можете отключать или комментировать ненужные модули, удаляя или изменяя строки, которые добавляют файлы в сборку, например, с помощью Makefile или в коде, где инициализируются эти модули.

Таким образом, файлы в каталоге `src/` делятся на несколько категорий:
- **Основные модули** (например, `kore.c`, `http.c`)
- **Вспомогательные модули** для работы с буферами, памятью, таймерами и т.д.
- **Специфичные модули** для работы с базами данных, криптографией, TLS и другими функциональностями.

Если вам не нужны какие-то функциональности, вы можете отключить их, исключив соответствующие файлы из сборки в Makefile.